## 一、实验目的

- 理解页表的建立和使用方法
- 理解物理内存的管理方法
- 理解页面分配算法

​	实验一过后我们做出来了一个可以启动的系统，实验二主要涉及操作系统的物理内存管理。操作系统为了使

用内存，还需高效地管理内存资源。本次实验我们会了解如何发现系统中的物理内存，然后学习如何建立对

物理内存的初步管理，即了解连续物理内存管理，最后掌握页表相关的操作，即如何建立页表来实现虚拟内

存到物理内存之间的映射，帮助我们对段页式内存管理机制有一个比较全面的了解。本次的实验主要是在实

验一的基础上完成物理内存管理，并建立一个最简单的页表映射。

## 二、实验过程

#### 练习0：填写已有实验

本实验依赖实验1。请把你做的实验1的代码填入本实验中代码中有“LAB1”的注释相应部分并按照实验手册进行进一步的修改。具体来说，就是跟着实验手册的教程一步步做，然后完成教程后继续完成完成exercise部分的剩余练习。(具体过程较为机械，不过多阐述)。

#### 练习1：理解first-fit 连续物理内存分配算法（思考题）
first-fit 连续物理内存分配算法作为物理内存分配一个很基础的方法，需要同学们理解它的实现过程。请大家仔细阅读实验手册的教程并结合`kern/mm/default_pmm.c`中的相关代码，认真分析default_init，default_init_memmap，default_alloc_pages， default_free_pages等相关函数，并描述程序在进行物理内存分配的过程以及各个函数的作用。
请在实验报告中简要说明你的设计实现过程。请回答如下问题：
- 你的first fit算法是否有进一步的改进空间？



#### 练习2：实现 Best-Fit 连续物理内存分配算法（需要编程）
在完成练习一后，参考kern/mm/default_pmm.c对First Fit算法的实现，编程实现Best Fit页面分配算法，算法的时空复杂度不做要求，能通过测试即可。
请在实验报告中简要说明你的设计实现过程，阐述代码是如何对物理内存进行分配和释放，并回答如下问题：
- 你的 Best-Fit 算法是否有进一步的改进空间？


#### 扩展练习Challenge：buddy system（伙伴系统）分配算法（需要编程）

Buddy System算法把系统中的可用存储空间划分为存储块(Block)来进行管理, 每个存储块的大小必须是2的n次幂(Pow(2, n)), 即1, 2, 4, 8, 16, 32, 64, 128...

 -  参考[伙伴分配器的一个极简实现](http://coolshell.cn/articles/10427.html)， 在ucore中实现buddy system分配算法，要求有比较充分的测试用例说明实现的正确性，需要有设计文档。
 
#### 扩展练习Challenge：任意大小的内存单元slub分配算法（需要编程）

slub算法，实现两层架构的高效内存单元分配，第一层是基于页大小的内存分配，第二层是在第一层基础上实现基于任意大小的内存分配。可简化实现，能够体现其主体思想即可。

 - 参考[linux的slub分配算法/](http://www.ibm.com/developerworks/cn/linux/l-cn-slub/)，在ucore中实现slub分配算法。要求有比较充分的测试用例说明实现的正确性，需要有设计文档。

尝试过，但是一直未能成功运行。

整体思路为首先实现第一层（页级内存管理），实现对固定大小内存页的分配和释放。
和前面类似使用
**slub_init**：初始化页级内存管理器，将 `free_list` 链表置空并将可用页数 `nr_free` 设置为 0。

 **slub_init_memmap**：初始化内存映射，主要将从 `base` 开始的 `n` 个 `Page` 页（模拟物理页结构）加入 `free_list` 中。 通过循环清空每个页的标志位 `flags` 和 `property`，并重置引用计数 `page_ref`。 将 `base` 页的 `property` 设置为页数 `n` 并加入 `free_list`，同时更新空闲页数 `nr_free`。

**slub_alloc_pages**：从 `free_list` 中分配指定数量的页。
遍历 `free_list`，寻找 `property` 大于或等于请求页数 `n` 的页。若找到合适的页块，将其从链表中删除并更新剩余页信息。如果页块大小超过请求的 `n` 页，则将剩余部分重新插入 `free_list`。成功分配后返回页地址，否则返回 `NULL`。

**slub_free_pages**：将释放的页重新插入 `free_list`，以便后续分配。
清空每个页的标志位和引用计数。将 `base` 页的 `property` 设置为 `n`，并更新 `nr_free`。遍历 `free_list`，按地址大小将 `base` 插入链表合适位置，以保持链表有序。

之后完成第二部分设计这一部分的设计目的是在分配比页更小的对象时提高内存利用率，并避免频繁分配整页。

**slub_cache_t**：定义一个 SLUB 缓存结构，包含：`obj_size`：对象的大小，经过对齐处理。free_objects`：链表存放空闲对象。

**create_slub_cache**：创建并初始化 SLUB 缓存结构。对象大小 `obj_size` 会对齐到 8 字节，以便在不同架构上优化内存访问。将 `free_objects` 链表初始化为空。

**slub_alloc_object**：从缓存中分配一个对象。如果 `free_objects` 中有可用对象，直接返回首个空闲对象。如果没有可用对象，调用 `slub_alloc_pages` 分配一个整页，然后将页内按 `obj_size` 大小分成小块，将每个小块作为对象添加到 `free_objects`。最终返回一个对象。

**slub_free_object**：释放对象并将其重新放入 `free_objects` 中。

最后进行检测。





#### 扩展练习Challenge：硬件的可用物理内存范围的获取方法（思考题）
  - 如果 OS 无法提前知道当前硬件的可用物理内存范围，请问你有何办法让 OS 获取可用物理内存范围？


> Challenges是选做，完成Challenge的同学可单独提交Challenge。完成得好的同学可获得最终考试成绩的加分。